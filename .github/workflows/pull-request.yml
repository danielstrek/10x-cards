name: Pull Request Checks

on:
  pull_request:
    branches: ["main"]

jobs:
  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: ".nvmrc"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint

  unit-test:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: ".nvmrc"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests with coverage
        run: npm run test:unit:coverage

      - name: Upload unit test coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-unit
          path: coverage/
          retention-days: 7

  status-comment:
    name: PR Status Comment
    runs-on: ubuntu-latest
    needs: [unit-test]
    if: always()
    permissions:
      pull-requests: write
    steps:
      - name: Download unit test coverage
        uses: actions/download-artifact@v4
        with:
          name: coverage-unit
          path: coverage/
        continue-on-error: true

      - name: Generate status comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            // Get job statuses
            const jobs = {
              lint: '${{ needs.lint.result }}',
              unitTest: '${{ needs.unit-test.result }}',
            };

            // Helper to create status emoji
            const getStatusEmoji = (status) => {
              switch(status) {
                case 'success': return 'âœ…';
                case 'failure': return 'âŒ';
                case 'cancelled': return 'âš ï¸';
                case 'skipped': return 'â­ï¸';
                default: return 'â“';
              }
            };

            // Build comment body
            let commentBody = '## ðŸ” Pull Request Check Results\n\n';
            commentBody += '### Job Status\n\n';
            commentBody += `| Job | Status |\n`;
            commentBody += `|-----|--------|\n`;
            commentBody += `| Lint | ${getStatusEmoji(jobs.lint)} ${jobs.lint} |\n`;
            commentBody += `| Unit Tests | ${getStatusEmoji(jobs.unitTest)} ${jobs.unitTest} |\n`;
            commentBody += '\n';

            // Overall status
            const allSuccess = Object.values(jobs).every(status => status === 'success');
            if (allSuccess) {
              commentBody += '### âœ… All checks passed!\n\n';
              commentBody += 'Your pull request is ready for review.\n';
            } else {
              commentBody += '### âš ï¸ Some checks failed\n\n';
              commentBody += 'Please review the failed jobs and fix any issues.\n';
            }

            // Try to read coverage summary
            try {
              const coveragePath = path.join('coverage', 'coverage-summary.json');
              if (fs.existsSync(coveragePath)) {
                const coverageData = JSON.parse(fs.readFileSync(coveragePath, 'utf8'));
                const total = coverageData.total;
                
                commentBody += '\n### ðŸ“Š Unit Test Coverage\n\n';
                commentBody += `| Metric | Coverage |\n`;
                commentBody += `|--------|----------|\n`;
                commentBody += `| Lines | ${total.lines.pct}% |\n`;
                commentBody += `| Statements | ${total.statements.pct}% |\n`;
                commentBody += `| Functions | ${total.functions.pct}% |\n`;
                commentBody += `| Branches | ${total.branches.pct}% |\n`;
              }
            } catch (error) {
              console.log('Coverage summary not available');
            }

            commentBody += '\n---\n';
            commentBody += `*Workflow run: [#${context.runNumber}](${context.payload.repository.html_url}/actions/runs/${context.runId})*\n`;

            // Find existing comment to update or create new one
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Pull Request Check Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            }
